<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <title>Ultimate IT Christmas Tree</title>

    <style>

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }



        /* AR Camera Feed */

        #ar-video, .arjs-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            display: block;
            transform: scaleX(-1);
            filter: brightness(0.8); /* Darken reality slightly to make holograms pop */
        }



        #canvas-container {

            position: fixed;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

            z-index: 1;

        }



        /* HUD Overlay */

        #ui-layer {

            position: fixed;

            bottom: 30px;

            width: 100%;
            z-index: 10;
            display: flex;
            justify-content: center;

            gap: 20px;

            pointer-events: none;

        }



        .hud-btn {

            pointer-events: auto;

            background: rgba(0, 20, 0, 0.6);

            border: 1px solid #00ff41;

            color: #00ff41;

            padding: 12px 24px;

            border-radius: 4px;

            font-weight: bold;

            text-transform: uppercase;

            letter-spacing: 2px;

            cursor: pointer;

            backdrop-filter: blur(4px);

            box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);

            transition: all 0.3s ease;

        }



        .hud-btn:hover {

            background: rgba(0, 255, 65, 0.2);

            box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);

            text-shadow: 0 0 5px #00ff41;

        }



        /* Loading Screen */

        #loader {

            position: fixed;

            top: 0;

            left: 0;

            width: 100%;

            height: 100%;

            background: #000;

            z-index: 20;

            display: flex;

            flex-direction: column;

            justify-content: center;

            align-items: center;

            color: #00ff41;

            transition: opacity 0.8s ease-out;

        }



        .terminal-text {

            font-size: 1.2rem;

            margin-top: 15px;

            animation: blink 1s infinite;

        }



        @keyframes blink { 50% { opacity: 0; } }



        /* Progress Bar */

        .progress-container {

            width: 200px;

            height: 4px;

            background: #111;

            margin-top: 20px;

            border-radius: 2px;

            overflow: hidden;

        }

        .progress-bar {

            width: 0%;

            height: 100%;

            background: #00ff41;

            box-shadow: 0 0 10px #00ff41;

            animation: load 2s ease-out forwards;

        }

        @keyframes load { 100% { width: 100%; } }

        /* Status Bar */
        #status-bar {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #00ff41;
            color: #00ff41;
            border-radius: 4px;
            z-index: 9;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.4);
            backdrop-filter: blur(6px);
        }

    </style>



    <!-- Three.js Core (r110, compatible with AR.js 3.x) -->

    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/build/three.min.js"></script>

    <!-- AR.js (local first; CDN fallback handled in code) -->
    <script src="./ar.js"></script>
    
    

    <!-- Post Processing Dependencies (Required for Glow/Bloom) -->

    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/shaders/CopyShader.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/postprocessing/EffectComposer.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/postprocessing/ShaderPass.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/postprocessing/RenderPass.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.110.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

</head>

<body>



    <div id="canvas-container"></div>

    <div id="status-bar"><span id="status-text">Initializing camera...</span></div>


    <div id="loader">

        <div style="font-size: 3rem;">❄️</div>

        <div class="terminal-text">>> INITIALIZING AR MARKER PIPELINE...</div>

        <div class="progress-container"><div class="progress-bar"></div></div>

    </div>



    <div id="ui-layer">

        <button class="hud-btn" id="toggle-dance">Dance</button>
        <button class="hud-btn" id="reset-pose">Reset View</button>

    </div>



    <script>

        // --- System Config ---

        const config = {

            danceSpeed: 2.5,

            isDancing: false,


            bloomThreshold: 0.1,
            bloomStrength: 1.4,
            bloomRadius: 0.25,
            baseScale: 0.18

        };



        // --- Globals ---

        let scene, camera, renderer, composer;

        let treeGroup, binarySnowSystem;
        let arToolkitSource, arToolkitContext, markerRoot, contentRoot;
        let markerVisibleLast = false;

        let clock = new THREE.Clock();

        const statusText = document.getElementById('status-text');
        const loaderEl = document.getElementById('loader');



        // --- AR.js Loader ---

        const arScriptCandidates = [
            // Local first (best when offline / behind firewall)
            './ar.js',
            './libs/ar.js',
            '/ar.js',
            '/libs/ar.js',
            // CDN fallbacks (3.3.2 mirrors)
            'https://unpkg.com/@ar-js-org/ar.js@3.3.2/three.js/build/ar.js',
            'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/3.3.2/three.js/build/ar.js',
            'https://raw.githack.com/AR-js-org/AR.js/3.3.2/three.js/build/ar.js'
        ];

        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const tag = document.createElement('script');
                tag.src = url;
                tag.async = true;
                tag.onload = resolve;
                tag.onerror = () => reject(new Error('Failed to load ' + url));
                document.head.appendChild(tag);
            });
        }

        async function ensureARLoaded() {
            if (window.THREEx && THREEx.ArToolkitSource) return;
            setStatus('Loading AR.js...');
            let lastErr;
            for (const url of arScriptCandidates) {
                try {
                    await loadScript(url);
                    if (window.THREEx && THREEx.ArToolkitSource) return;
                } catch (err) {
                    lastErr = err;
                    console.warn('[AR] load attempt failed', url, err);
                }
            }
            throw lastErr || new Error('AR.js not available');
        }



        function init() {

            // 1. Scene Setup

            scene = new THREE.Scene();
            

            // Camera driven by AR.js (projection set after ARToolkit init)

            camera = new THREE.Camera();
            scene.add(camera);



            // 2. Renderer with High Performance settings

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });

            renderer.setSize(window.innerWidth, window.innerHeight);

            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance

            renderer.toneMapping = THREE.ReinhardToneMapping;

            renderer.setClearColor(0x000000, 0); // Keep canvas transparent so video shows through

            document.getElementById('canvas-container').appendChild(renderer.domElement);



            // 3. Post-Processing (BLOOM)

            const renderScene = new THREE.RenderPass(scene, camera);
            

            // Bloom Pass parameters: resolution, strength, radius, threshold

            const bloomPass = new THREE.UnrealBloomPass(

                new THREE.Vector2(window.innerWidth, window.innerHeight), 

                config.bloomStrength, 

                config.bloomRadius, 

                config.bloomThreshold

            );



            composer = new THREE.EffectComposer(renderer);

            composer.addPass(renderScene);

            composer.addPass(bloomPass);



            // 4. Lighting (Dramatic)

            const ambient = new THREE.AmbientLight(0xffffff, 0.1); // Low ambient to let emissive pop

            scene.add(ambient);



            const keyLight = new THREE.DirectionalLight(0xffffff, 1);

            keyLight.position.set(5, 5, 5);

            scene.add(keyLight);



            // Cyberpunk rim lights

            const blueRim = new THREE.PointLight(0x0088ff, 2, 20);

            blueRim.position.set(-5, 2, 2);

            scene.add(blueRim);



            const greenRim = new THREE.PointLight(0x00ff41, 1, 20);

            greenRim.position.set(5, 0, 2);

            scene.add(greenRim);



            // 5. AR marker tracking setup

            setupARTracking();



            // 6. Build The Masterpiece anchored to the marker

            buildTree();

            buildBinarySnow();

            const targetRoot = contentRoot || markerRoot || scene;
            targetRoot.add(treeGroup);
            targetRoot.add(binarySnowSystem);
            targetRoot.scale.setScalar(config.baseScale);
            targetRoot.position.set(0, 0, 0);
            targetRoot.rotation.set(0, 0, 0);



            // 7. Listeners

            window.addEventListener('resize', onResize);

            document.getElementById('toggle-dance').addEventListener('click', () => config.isDancing = !config.isDancing);
            document.getElementById('reset-pose').addEventListener('click', resetPose);



            // 8. Start Animation

            animate();



            // Hide Loader

            setTimeout(() => hideLoader(), 1500);

        }


        function resetPose() {
            if (contentRoot) {
                contentRoot.position.set(0, 0, 0);
                contentRoot.rotation.set(0, 0, 0);
                contentRoot.scale.setScalar(config.baseScale);
            }
            if (treeGroup) treeGroup.position.set(0, 0, 0);
            if (binarySnowSystem) binarySnowSystem.position.set(0, 0, 0);
        }



        // --- The Tree Construction ---

        function buildTree() {

            treeGroup = new THREE.Group();



            // Materials - High Quality

            const leafMat = new THREE.MeshStandardMaterial({ 

                color: 0x0f4d0f, 

                roughness: 0.4, 

                metalness: 0.3 

            });

            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9 });



            // Trunk

            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, 2, 16), trunkMat);

            trunk.position.y = 1;

            treeGroup.add(trunk);



            // Layers

            const layers = 6;

            for(let i=0; i<layers; i++) {

                const t = i / layers;

                const r = 2.8 * (1 - t * 0.85);

                const h = 1.5;

                const y = 1.8 + (i * 0.9);



                const cone = new THREE.Mesh(new THREE.ConeGeometry(r, h, 32), leafMat);

                cone.position.y = y;

                treeGroup.add(cone);



                // Add Decorations

                addITOrnaments(cone, r, h);

                addGlowingLights(cone, r, h);

            }



            // Topper: The "CPU" Star

            const starGroup = new THREE.Group();

            const starGeo = new THREE.IcosahedronGeometry(0.5, 0);

            const starMat = new THREE.MeshStandardMaterial({ 

                color: 0xffd700, 

                emissive: 0xffaa00, 

                emissiveIntensity: 2.0, // Glows brightly

                roughness: 0.1,

                metalness: 1.0

            });

            const star = new THREE.Mesh(starGeo, starMat);

            starGroup.position.y = 1.8 + ((layers-1) * 0.9) + 0.8;

            starGroup.add(star);
            

            // Orbiting Electrons for Star

            for(let i=0; i<3; i++) {

                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.8, 0.02, 8, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 }));

                ring.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);

                starGroup.add(ring);

            }

            treeGroup.add(starGroup);

            treeGroup.userData.star = starGroup;



            // Holographic Sign (Frontmost)

            addHologramSign();



            // Gifts

            addGifts();



            const parent = contentRoot || markerRoot || scene;
            parent.add(treeGroup);

        }



        // --- Ornaments: IT Hardware ---

        function addITOrnaments(parent, r, h) {

            const count = 10;

            for(let i=0; i<count; i++) {

                let mesh;

                const type = Math.random();

                if(type < 0.3) mesh = createFloppy();

                else if(type < 0.6) mesh = createUSB();

                else if(type < 0.8) mesh = createRamStick();

                else mesh = createMouse();



                const angle = Math.random() * Math.PI * 2;

                const rad = r * 0.75;

                const y = -h * 0.3 + (Math.random() * 0.4 - 0.2);



                mesh.position.set(Math.cos(angle)*rad, y, Math.sin(angle)*rad);

                mesh.rotation.set(Math.random(), Math.random(), Math.random());

                mesh.scale.setScalar(0.7);

                parent.add(mesh);

            }

        }



        // --- Lights: Emissive for Bloom ---

        function addGlowingLights(parent, r, h) {

            const count = 18;

            const colors = [0xff0000, 0x00ff00, 0x0088ff, 0xffaa00, 0xff00ff];

            const geo = new THREE.SphereGeometry(0.08, 16, 16);



            for(let i=0; i<count; i++) {

                const color = colors[Math.floor(Math.random() * colors.length)];

                // EmissiveIntensity > 1 triggers the bloom effect

                const mat = new THREE.MeshStandardMaterial({ 

                    color: 0x000000, 

                    emissive: color, 

                    emissiveIntensity: 3.0 

                });

                const mesh = new THREE.Mesh(geo, mat);



                const angle = Math.random() * Math.PI * 2;

                // Distribute slightly outside the leaves

                const y = -h * Math.random() * 0.8;

                const slopeRadius = r * (1 - (Math.abs(y)/h)) + 0.1;



                mesh.position.set(Math.cos(angle)*slopeRadius, y, Math.sin(angle)*slopeRadius);

                parent.add(mesh);

            }

        }



        // --- Hardware Creators ---

        function createFloppy() {

            const g = new THREE.Group();

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.05), new THREE.MeshStandardMaterial({ color: 0x333333 }));

            const shutter = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.06), new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8 }));

            shutter.position.y = 0.1;

            g.add(body, shutter);

            return g;

        }

        function createUSB() {

            const g = new THREE.Group();

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.08), new THREE.MeshStandardMaterial({ color: 0xff3333 }));

            const tip = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.06), new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.9 }));

            tip.position.y = 0.27;

            g.add(body, tip);

            return g;

        }

        function createRamStick() {

            const g = new THREE.Group();

            const pcb = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.15, 0.02), new THREE.MeshStandardMaterial({ color: 0x00aa00 }));

            const chips = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.08, 0.04), new THREE.MeshStandardMaterial({ color: 0x111111 }));

            g.add(pcb, chips);

            return g;

        }

        function createMouse() {

             const m = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffffff }));

             m.scale.set(1, 0.6, 1.4);

             const cord = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3), new THREE.MeshBasicMaterial({ color: 0x222222 }));

             cord.position.z = -0.2;

             cord.rotation.x = Math.PI/2;

             m.add(cord);

             return m;

        }



        // --- Hologram Sign ---

        function addHologramSign() {

            const canvas = document.createElement('canvas');

            canvas.width = 1024;

            canvas.height = 512;

            const ctx = canvas.getContext('2d');



            // Draw Neon Text

            ctx.fillStyle = "rgba(0,0,0,0)";

            ctx.clearRect(0,0,1024,512);
            

            ctx.shadowColor = "#00ff41";

            ctx.shadowBlur = 30;

            ctx.fillStyle = "#ffffff";

            ctx.textAlign = "center";

            ctx.font = "bold 90px Courier New";

            ctx.fillText("MERRY CHRISTMAS", 512, 200);
            

            ctx.shadowColor = "#0088ff";

            ctx.font = "bold 70px Courier New";

            ctx.fillText("FROM HSB IT DEPT", 512, 320);



            // Scanlines

            ctx.shadowBlur = 0;

            ctx.fillStyle = "rgba(255, 255, 255, 0.1)";

            for(let i=0; i<512; i+=6) ctx.fillRect(0,i,1024,2);



            const tex = new THREE.CanvasTexture(canvas);

            const mat = new THREE.SpriteMaterial({ 

                map: tex, 

                transparent: true, 

                opacity: 0.95,

                blending: THREE.AdditiveBlending,

                depthTest: false // Always show on top

            });



            const sprite = new THREE.Sprite(mat);

            sprite.scale.set(6, 3, 1);

            sprite.position.set(0, 3.5, 3.0); // Front and Center

            sprite.renderOrder = 999;

            treeGroup.add(sprite);

            treeGroup.userData.sign = sprite;

        }



        // --- Gifts ---

        function addGifts() {

            const group = new THREE.Group();

            // Server Rack

            const rack = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 0.8), new THREE.MeshStandardMaterial({ color: 0x222222 }));

            rack.position.set(-1.5, 0.2, 1.5);

            // Emissive Lights on Rack

            const leds = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.05, 0.82), new THREE.MeshStandardMaterial({ color: 0x000000, emissive: 0x00ff00, emissiveIntensity: 5 }));

            rack.add(leds);

            group.add(rack);



            // PC Tower

            const pc = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.9, 0.8), new THREE.MeshStandardMaterial({ color: 0x111111 }));

            pc.position.set(1.5, 0.45, 1.2);

            // RGB Strip

            const strip = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.8, 0.05), new THREE.MeshStandardMaterial({ color: 0x000000, emissive: 0xff00ff, emissiveIntensity: 3 }));

            strip.position.z = 0.38;

            pc.add(strip);

            group.add(pc);



            // Laptops

            for(let i=0; i<3; i++) {

                const box = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.6), new THREE.MeshStandardMaterial({ color: 0xffffff }));

                const ribbon = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.11, 0.61), new THREE.MeshStandardMaterial({ color: 0x0000ff }));

                box.add(ribbon);

                const a = Math.random() * Math.PI * 2;

                const d = 2 + Math.random();

                box.position.set(Math.cos(a)*d, 0.05, Math.sin(a)*d);

                box.rotation.y = Math.random();

                group.add(box);

            }



            treeGroup.add(group);

        }



        // --- Binary Snow System ---

        function buildBinarySnow() {

            const count = 1000;

            const geometry = new THREE.BufferGeometry();

            const positions = [];

            const speeds = [];



            for(let i=0; i<count; i++) {

                positions.push(

                    (Math.random() - 0.5) * 40,

                    (Math.random() - 0.5) * 40 + 10,

                    (Math.random() - 0.5) * 40

                );

                speeds.push(0.05 + Math.random() * 0.1);

            }



            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            geometry.setAttribute('speed', new THREE.Float32BufferAttribute(speeds, 1));



            // Use a simple point material for performance, but we simulate 0s and 1s via blinking in mind

            // Ideally we'd use a texture atlas for '0' and '1', but for single-file, squares work as "bits"

            const material = new THREE.PointsMaterial({

                color: 0x00ff41,

                size: 0.2,

                transparent: true,

                opacity: 0.8,

                blending: THREE.AdditiveBlending

            });



            binarySnowSystem = new THREE.Points(geometry, material);

            const parent = contentRoot || markerRoot || scene;
            parent.add(binarySnowSystem);

        }



        // --- AR.js Tracking + UI helpers ---

        function setStatus(message) {
            if (statusText) statusText.textContent = message;
        }

        function setErrorStatus(message, err) {
            if (err) console.error('[AR]', message, err);
            else console.error('[AR]', message);
            setStatus(message);
        }


        function hideLoader() {
            if (!loaderEl) return;
            loaderEl.style.opacity = 0;
            setTimeout(() => loaderEl.remove(), 800);
        }


        function attachARVideo() {
            const video = arToolkitSource.domElement;
            if (!video) return;
            video.setAttribute('id', 'ar-video');
            video.setAttribute('playsinline', 'true');
            video.setAttribute('autoplay', 'true');
            video.setAttribute('muted', 'true');
            video.muted = true;
            video.style.position = 'fixed';
            video.style.top = '0';
            video.style.left = '0';
            video.style.width = '100%';
            video.style.height = '100%';
            video.style.objectFit = 'cover';
            video.style.transform = 'scaleX(-1)';
            video.style.zIndex = 0;
            document.body.insertBefore(video, document.getElementById('canvas-container'));
        }


        function setupARTracking() {

            if (!window.THREEx || !THREEx.ArToolkitSource || !THREEx.ArToolkitContext) {
                setErrorStatus('AR.js failed to load. Check network/console.');
                hideLoader();
                return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                setErrorStatus('Camera APIs unavailable in this browser/page.');
                hideLoader();
                return;
            }

            setStatus('Requesting camera access...');

            try {
                arToolkitSource = new THREEx.ArToolkitSource({
                    sourceType: 'webcam',
                    sourceWidth: 1280,
                    sourceHeight: 720
                });

                arToolkitSource.init(() => {
                    attachARVideo();
                    onResize();
                    hideLoader();
                    setStatus('Point at pattern-2.png');
                });

                // If init never fires (e.g., permission blocked), fall back with a hint
                setTimeout(() => {
                    if (!arToolkitSource || !arToolkitSource.ready) {
                        setErrorStatus('Camera blocked or unavailable. Allow access and reload.');
                        hideLoader();
                    }
                }, 5000);

            arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: './camera_para.dat',
                detectionMode: 'mono',
                maxDetectionRate: 30
            });

                arToolkitContext.init(() => {
                    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
                });

                markerRoot = new THREE.Group();
                markerRoot.matrixAutoUpdate = false;
                markerRoot.visible = false;
                scene.add(markerRoot);

                contentRoot = new THREE.Group();
                markerRoot.add(contentRoot);

                new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
                    type: 'pattern',
                    patternUrl: 'pattern-2.patt',
                    changeMatrixMode: 'modelViewMatrix'
                });

                // Safety net to hide loader even if init is slow
                setTimeout(hideLoader, 3500);

            } catch (err) {
                setErrorStatus('AR init failed. See console.', err);
                hideLoader();
            }
        }



        // --- Interaction ---

        function onResize() {

            if (arToolkitSource) {
                arToolkitSource.onResizeElement();
                arToolkitSource.copyElementSizeTo(renderer.domElement);
                if (arToolkitContext && arToolkitContext.arController !== null) {
                    arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas);
                }
            } else {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            composer.setSize(renderer.domElement.width, renderer.domElement.height);

        }



        // --- Loop ---

        function animate() {

            requestAnimationFrame(animate);



            if (arToolkitSource && arToolkitSource.ready) {
                arToolkitContext.update(arToolkitSource.domElement);

                if (markerRoot) {
                    const visible = markerRoot.visible;
                    if (visible !== markerVisibleLast) {
                        markerVisibleLast = visible;
                        setStatus(visible ? 'Marker locked ✅' : 'Point at pattern-2.png');
                    }
                }
            }



            const time = clock.getElapsedTime();



            if (treeGroup && config.isDancing && (!markerRoot || markerRoot.visible)) {

                // Smooth bounce

                const bounce = Math.sin(time * config.danceSpeed) * 0.03;

                treeGroup.scale.set(1 - bounce, 1 + bounce*2, 1 - bounce);
                

                // Gentle swaying

                treeGroup.rotation.z = Math.cos(time * 2) * 0.02;
                

                // Rotate entire tree slowly for showcase

                treeGroup.rotation.y = time * 0.2;



                // Sign animation

                if(treeGroup.userData.sign) {

                    treeGroup.userData.sign.material.opacity = 0.8 + Math.sin(time * 10) * 0.2; // Glitch flicker

                    // Counter-rotate sign so it always faces broadly front relative to tree spin

                    // actually, simpler: just let it spin with tree but maybe pulse

                }

            }



            // Animate Binary Snow

            if (binarySnowSystem) {

                const positions = binarySnowSystem.geometry.attributes.position.array;

                const speeds = binarySnowSystem.geometry.attributes.speed.array;
                

                for(let i=0; i<speeds.length; i++) {

                    positions[i*3 + 1] -= speeds[i]; // Move Y down

                    if(positions[i*3 + 1] < -5) {

                        positions[i*3 + 1] = 20; // Reset to top

                    }

                }

                binarySnowSystem.geometry.attributes.position.needsUpdate = true;

            }



            // Render via Composer (Bloom) instead of plain renderer

            composer.render();

        }



        ensureARLoaded()
            .then(() => init())
            .catch(err => setErrorStatus('AR.js failed to load. Check network/console.', err));

    </script>

</body>

</html>

